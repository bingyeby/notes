ES6 完全使用手册 https://juejin.im/post/5bfe05505188252098022400



# ES6总结
    一、新的变量声明方式 let/const
    二、 箭头函数的使用 那就是箭头函数中，没有this。如果你在箭头函数中使用了this，那么该this一定就是外层的this。
    三、模板字符串
    四、 解析结构
    五、 函数默认参数
    六、 展开运算符 在ES6中用...来表示展开运算符，它可以将数组方法或者对象进行展开
    七、对象字面量 与 class



## 字符串
### str.codePointAt(0)
JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。
```
var s = "𠮷";
s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```
上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。

对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。

ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。
```
var s = '𠮷a';
s.codePointAt(0) // 134071
s.codePointAt(1) // 57271
s.codePointAt(2) // 97
```

你可能注意到了，codePointAt方法的参数，仍然是不正确的。

比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向codePointAt方法传入2。

解决这个问题的一个办法是使用for...of循环，因为它会正确识别32位的UTF-16字符。

```
var s = '𠮷a';
for (let ch of s) {
    console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61

```
**ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。**
    

### String.fromCodePoint()
    ES6提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。
    String.fromCodePoint(0x20BB7) // "𠮷"
    String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y' // true

### str.at(0)
    ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。
    'abc'.charAt(0) // "a"
    '𠮷'.charAt(0) // "\uD842"

    字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。
    'abc'.at(0) // "a"
    '𠮷'.at(0) // "𠮷"

### includes(), startsWith(), endsWith()
    indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。
    includes()：返回布尔值，表示是否找到了参数字符串。
    startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
    endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

    var s = 'Hello world!';
    s.startsWith('Hello') // true
    s.endsWith('!') // true
    s.includes('o') // true
    这三个方法都支持第二个参数，表示开始搜索的位置。
    s.startsWith('world', 6) // true
    s.endsWith('Hello', 5) // true
    s.includes('Hello', 6) // false

### str.repeat(n)
    小数、字符串会转化为整数；
    负数、Infinity则会报错；
    NaN、""、"str"等同于0
#### 
    'x'.repeat(3) // "xxx"
    'hello'.repeat(2) // "hellohello"
    'na'.repeat(0) // ""
    'na'.repeat(2.9) // "nana"
    'na'.repeat(-0.9) // ""
    'na'.repeat(NaN) // ""  
    'na'.repeat('na') // ""
    "a".repeat("") // ""
    'na'.repeat('3') // "nanana"

### padStart() padEnd()
    padStart()用于头部补全，padEnd()用于尾部补全。

### 字符串模板
    模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中
    模板字符串中通过${}嵌入变量；{}中可以写入js表达式、引用对象属性、调用函数
    `${x} + ${y * 2} = ${x + y * 2}`
    `foo ${fn()} bar`
    模板字符串紧跟在一个函数名称的后面，该函数将被调用来处理此字符串模板（称为标签模板功能 tagged template）

## 数组
### 扩展运算符的应用
    合并数组 [1,2,...arr1,...arr2]
    与解构赋值结合 const [first, ...rest] = [1, 2, 3, 4, 5];
    将字符串转换为真正的数组 [...'hello'] 可以正确识别32Unicode字符 [...str].reverse().join('')
    任何Iterator接口的对象，都可以通过扩展符转换为数组  [...document.querySelectorAll('div')]
        Map Set Generator函数
            var go = function*(){ yield 1; yield 2; yield 3; };
            [...go()] // [1, 2, 3]
        对没有iterator接口的对象使用扩展运算符将会报错
    函数的返回值 

### API其他
    Array.from() 用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）
    Array.of() 用于将一组值，转换为数组。Array.of(3, 11, 8) // [3,11,8]
    arr.copyWithin(target, start = 0, end = this.length) 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
    arr.find(fn) 
    arr.findIndex(fn) 
        [NaN].indexOf(NaN) // -1
        [NaN].findIndex(y => Object.is(NaN, y)) // 0
    arr.includes() [1, 2, NaN].includes(NaN) // true
    arr.fill()
    arr.entries() arr.keys() arr.values()

### map
```js
//  数组去重
[...new Set(array)]

//  map遍历
let map = new Map(arr);
for (let key of map.keys()) { console.log(key); }
for (let value of map.values()) { console.log(value); }
for (let item of map.entries()) { console.log(item[0], item[1]); } // key value
for (let [key, value] of data) { console.log(key , value) } // key value
```

## Promise小结
### 基础知识
Promise对象有以下两个特点。
* 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
* 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

### 基础语法
```js
Promise.prototype.then()
Promise.prototype.catch()
Promise.all()
Promise.race()
Promise.resolve()
Promise.reject()
```

### 两个有用的附加方法
#### done()
Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。
```js
Promise.prototype.done = function (onFulfilled, onRejected) {
    this.then(onFulfilled, onRejected)
        .catch(function (reason) {
            // 抛出一个全局错误
            setTimeout(() => { throw reason }, 0);
        });
};
```
#### finally()
finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。
```js
Promise.prototype.finally = function (callback) {
    let P = this.constructor;
    return this.then(
        value  => P.resolve(callback()).then(() => value),
        reason => P.resolve(callback()).then(() => { throw reason })
    );
};
```

### bluebird
#### 安装
    npm install bluebird
#### Promise.try()
    原文：
    http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/
    翻译：
    http://www.zcfy.cc/article/what-is-promise-try-and-why-does-it-matter-joepie91-s-ramblings-385.html
    [译] 什么是Promise.try，它为何重要？
    以上的代码看起来似乎是多余的。但实际上它有以下几个优点：
    1.更好的错误处理 同步代码中的异常不论出现在何处都会以rejection的形式向Promise链后端传递。
    2.更好的兼容性 你可以始终使用你自己喜欢的Promise实现，而不用担心第三方代码在使用哪个。
    3.更好的代码阅读体验 所有的代码在水平方向上将处于同一个缩进层级，这将使你阅读代码变得更容易。

    http://ricostacruz.com/cheatsheets/bluebird.html
    bluebird.js cheatsheet
	

    https://github.com/xieranmaya/blog/issues/3
    剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类 （其他：性能 停止一个promise链 .done 最佳实战）




## 小技巧

### 利用数组解构来实现值的互换
```js
let a = 'world', b = 'hello'
[a, b] = [b, a]
console.log(a) // -> hello
console.log(b) // -> world
```

### 展开符...实现数组的拼接
```js
const one = ['a', 'b', 'c']
const two = ['d', 'e', 'f']
const three = ['g', 'h', 'i']

const result = [...one, ...two, ...three]
```

### 命名参数
```js
const getStuffAwesome = ({id, name, force, verbose}) => {
    ...do stuff
}
// 完美
getStuffAwesome({ id: 150, force: true, verbose: true })
```

### Async/Await结合数组解构
```js
const [user, account] = await Promise.all([ fetch('/user'), fetch('/account') ]) 
```

